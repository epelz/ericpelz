{"data":{"site":{"siteMetadata":{"title":"Eric Pelz","author":"Eric Pelz"}},"markdownRemark":{"id":"8f315846-07a3-5c11-a85f-66026e0b21a2","excerpt":"“JavaScript is growing explosively and is now used in large mature projects even\noutside the web domain. JavaScript is also a dynamically typed language for…","html":"<p>“JavaScript is growing explosively and is now used in large mature projects even\noutside the web domain. JavaScript is also a dynamically typed language for\nwhich static type systems, notably Facebook’s Flow and Microsoft’s TypeScript,\nhave been written. What benefits do these static type systems provide?”</p>\n<p>“In this study, we empirically quantify how much static type systems improve\nsoftware quality. This is measured against bugs that are public, actually\nchecked in and visible to other developers, potentially impacting them; public\nbugs notably include field bugs, which impact users. We consider public bugs\nbecause they are observable in software repository histories. Public bugs are\nmore likely to be errors understanding the specification because they are\nusually tested and reviewed, and, in the case of field bugs, deployed. Thus,\nthis experiment under-approximates static type systems’ positive impact on\nsoftware quality, especially when one considers all their other potential\nbenefits on documentation, program performance, code completion, and code\nnavigation.”</p>\n<h2>Definition and methodology</h2>\n<p>” Definition 2.1 (ts-detectable): Given a static type system ts, a bug b is\nts-detectable when adding or changing type annotations causes the program p\ncontaining b to error on a line changed by a fix and the new annotations are\nconsistent with f , a fixed version of p.”</p>\n<p>The authors randomly selected 400 of the ~4 million closed issues of JavaScript\nprojects on Github (sufficient to achieve 95% confidence level)</p>\n<p>They time-boxed annotating types for each bug to 10 minutes. This 10 minute\nnumber was determined from a preliminary study on 78 bugs sampled (where they\nfound that 86.67% of bugs could be annotated or deemed not ts-detectable within\n10 minutes)</p>\n<h2>Results</h2>\n<p>Results:</p>\n<ul>\n<li>They were able to label all 400 bugs as either detectable or undetected under\nFlow and TypeScript. Flow detected 60, and TypeScript detected 60. At the\nconfidence level of 95%, this means the percentage of detectable bugs for both\nFlow and TypeScript fall into [11.5%, 18.5%] with mean 15%.</li>\n<li>Most of the bugs were easy to determine. Time-boxing to only 10 minutes per\nbug, they were able to determine all ut 18 of the 400 bugs. These remaining\nbugs took between 8 minutes to over a an hour of dedicated time (authors noted\nthat some were quicker than the first iteration, due to increasing expertise).</li>\n</ul>\n<p>Caveat:</p>\n<p>Authors think this is a greatly understated impact of static typing, because:</p>\n<ul>\n<li>They only surveyed publicly visible bugs, which means any bug caught during\ndevelopment were not included. They also think public bugs are more often due\nto misunderstanding of the specification, which type systems cannot detect.</li>\n<li>This doesn’t include any other strengths of static type systems, like\ndeveloper efficiency or app performance.</li>\n<li>This experiment uses relatively weak type systems of TypeScript and Flow.</li>\n<li>The authors have limited expertise in Flow and TypeScript, which means they\ncould have incorrectly deemed bug as undetectable.</li>\n</ul>\n<p>Classifying ts-undetectable bugs</p>\n<ul>\n<li>Most errors were “specification errors” - 186/400 (55%). Errors implementing\nspecification overwhelmingly constitute 78%. This demonstrates the importance\nof careful specification before development.</li>\n<li>StringError was the second most common error type - errors caused by incorrect\ncontent of a string (e.g. wrong URL).</li>\n<li>Authors theorize this is due to: (1) lots of URLs and other strings in\nJavaScript, (2) the string type being very opaque in most type systems.</li>\n</ul>\n<h3>TS vs Flow</h3>\n<ul>\n<li>TypeScript 2.0 added null handling. 22 of the 60 ts-detectable bugs needed\nnull checks (i.e. they needed —strictNullChecks and TS 2.0, rather than TS\n1.8).</li>\n<li>\n<p>TypeScript and Flow’s coverage were largely overlapping, with 6 exceptions: 3\nwere only Flow-detectable and 3 were only TypeScript detectable.</p>\n<ul>\n<li>All three Flow-detectable-only bugs were due to concatenating a possible\nundefined/null value with another string. For example, var x = ” ” + null +\n” ”; This highlighted a TypeScript weakness (at least as of version 2.0).</li>\n<li>Two of the three TypeScript-detectable-only bugs were due to Flow’s\nincomplete support for using string literals as an index.</li>\n</ul>\n</li>\n</ul>\n<h2>Cost</h2>\n<ul>\n<li>\n<p>Directly measuring the effort programmers must spend to annotate programs with\na static type system would be very hard. The authors instead approximate:\ntoken tax, “the number of tokens in the added type annotations”, and time tax,\n“the time spent adding annotations.”</p>\n<ul>\n<li>Token tax aims to proxy the number of decisions a programmer must make when\nadding type annotations. That is, for a ts-detectable bugs, the number of\ntokens in the annotation needed to trigger a type error.</li>\n</ul>\n</li>\n<li>These measures are a huge underestimate, because they only measure the\n“annotation tax” in a per-bug manner, where the authors have a very localized\nannotation effort determined only to target the bug in question (not the\nentire file).</li>\n<li>They lie under the assumption that the project has fully embraced using a\nstatic type checker, so the codebase would already be annotated prior to the\nbug being introduced. Thus, their metric measures just the time and tokens\nrequired for the <em>additional annotations</em> at the time of the bug-introducing\nchange. In other words, it measures incrementally adding/annotating patches on\nan already annotated code base.</li>\n<li>\n<p>Using this measure, they find the mean per-bug annotation tax: For Flow there\nare 1.7 tokens and 231 seconds required to detect a bug, and 2.4 tokens and\n306 seconds for TypeScript.</p>\n<ul>\n<li>Why discrepancy? Flow implements stronger type inference, and has a more\ncompact syntax for nullable types. This was most dramatic in the time saved\n— Flow frequently could infer types and thus the authors did not even need\nto read the bug report and fix to add a consistent type annotation.</li>\n</ul>\n</li>\n</ul>","frontmatter":{"title":"Quantifying Detectable Bugs in JavaScript","date":"March 24, 2019","description":"xcxc"},"fields":{"readingTime":{"text":"5 min read"}}}},"pageContext":{"slug":"/summary-quantifying-detectable-bugs-js/","previous":{"fields":{"slug":"/how-best-product-engineering-teams-max-value/"},"frontmatter":{"title":"How the best product engineering teams maximize value"}},"next":null}}