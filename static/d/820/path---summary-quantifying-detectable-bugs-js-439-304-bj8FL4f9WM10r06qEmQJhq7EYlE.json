{"data":{"site":{"siteMetadata":{"title":"Eric Pelz","author":"Eric Pelz"}},"markdownRemark":{"id":"8f315846-07a3-5c11-a85f-66026e0b21a2","excerpt":"“JavaScript is growing explosively and is now used in large mature projects even outside the web domain. JavaScript is also a dynamically typed language for…","html":"<p>“JavaScript is growing explosively and is now used in large mature projects even outside the web domain. JavaScript is also a dynamically typed language for which static type systems, notably Facebook’s Flow and Microsoft’s TypeScript, have been written. What benefits do these static type systems provide?”</p>\n<p>“In this study, we empirically quantify how much static type systems improve software quality. This is measured against bugs that are public, actually checked in and visible to other developers, potentially impacting them; public bugs notably include field bugs, which impact users. We consider public bugs because they are observable in software repository histories. Public bugs are more likely to be errors understanding the specification because they are usually tested and reviewed, and, in the case of field bugs, deployed. Thus, this experiment under-approximates static type systems’ positive impact on software quality, especially when one considers all their other potential benefits on documentation, program performance, code completion, and code navigation.”</p>\n<h2>Definition and methodology</h2>\n<p>” Definition 2.1 (ts-detectable): Given a static type system ts, a bug b is ts-detectable when adding or changing type annotations causes the program p containing b to error on a line changed by a fix and the new annotations are consistent with f , a fixed version of p.”</p>\n<p>The authors randomly selected 400 of the ~4 million closed issues of JavaScript projects on Github (sufficient to achieve 95% confidence level)</p>\n<p>They time-boxed annotating types for each bug to 10 minutes. This 10 minute number was determined from a preliminary study on 78 bugs sampled (where they found that 86.67% of bugs could be annotated or deemed not ts-detectable within 10 minutes)</p>\n<h2>Results</h2>\n<p>Results:</p>\n<ul>\n<li>They were able to label all 400 bugs as either detectable or undetected under Flow and TypeScript. Flow detected 60, and TypeScript detected 60. At the confidence level of 95%, this means the percentage of detectable bugs for both Flow and TypeScript fall into [11.5%, 18.5%] with mean 15%.</li>\n<li>Most of the bugs were easy to determine. Time-boxing to only 10 minutes per bug, they were able to determine all ut 18 of the 400 bugs. These remaining bugs took between 8 minutes to over a an hour of dedicated time (authors noted that some were quicker than the first iteration, due to increasing expertise).</li>\n</ul>\n<p>Caveat:</p>\n<p>Authors think this is a greatly understated impact of static typing, because:</p>\n<ul>\n<li>They only surveyed publicly visible bugs, which means any bug caught during development were not included. They also think public bugs are more often due to misunderstanding of the specification, which type systems cannot detect.</li>\n<li>This doesn’t include any other strengths of static type systems, like developer efficiency or app performance.</li>\n<li>This experiment uses relatively weak type systems of TypeScript and Flow.</li>\n<li>The authors have limited expertise in Flow and TypeScript, which means they could have incorrectly deemed bug as undetectable.</li>\n</ul>\n<p>Classifying ts-undetectable bugs</p>\n<ul>\n<li>Most errors were “specification errors” - 186/400 (55%). Errors implementing specification overwhelmingly constitute 78%. This demonstrates the importance of careful specification before development.</li>\n<li>StringError was the second most common error type - errors caused by incorrect content of a string (e.g. wrong URL).</li>\n<li>Authors theorize this is due to: (1) lots of URLs and other strings in JavaScript, (2) the string type being very opaque in most type systems.</li>\n</ul>","frontmatter":{"title":"Quantifying Detectable Bugs in JavaScript","date":"March 24, 2018","description":"xcxc"},"fields":{"readingTime":{"text":"3 min read"}}}},"pageContext":{"slug":"/summary-quantifying-detectable-bugs-js/","previous":{"fields":{"slug":"/circumventing-engineering-complexity/"},"frontmatter":{"title":"Circumventing engineering complexity"}},"next":{"fields":{"slug":"/how-best-product-engineering-teams-max-value/"},"frontmatter":{"title":"How the best product engineering teams maximize value"}}}}