{"data":{"site":{"siteMetadata":{"title":"Eric Pelz","author":"Eric Pelz"}},"markdownRemark":{"id":"8f315846-07a3-5c11-a85f-66026e0b21a2","excerpt":"It’s extremely common for engineering teams to debate the value of\nstatic versus dynamic typing systems, especially when developing\napplications on the web. The…","html":"<p>It’s extremely common for engineering teams to debate the value of\nstatic versus dynamic typing systems, especially when developing\napplications on the web. The last few years has seen a big rise in\nusage of TypeScript and Flow, which add static type checking to JavaScript (among other benefits).</p>\n<p>Within an engineering team, it’s fairly difficult to determine the\nactual value (or cost) that one attains from switching from a dynamic\nto static typing system.</p>\n<p>A group of researchers created a study to estimate just this: do static\ntype systems improve software quality, and if so, by how much?\nxcxc link to paper</p>\n<p>As a spoiler: 15% of the bugs were detectable by Flow 0.30 and TypeScript 2.0.</p>\n<p>xcxc remove\n“In this study, we empirically quantify how much static type systems improve\nsoftware quality. This is measured against bugs that are public, actually\nchecked in and visible to other developers, potentially impacting them; public\nbugs notably include field bugs, which impact users. We consider public bugs\nbecause they are observable in software repository histories. Public bugs are\nmore likely to be errors understanding the specification because they are\nusually tested and reviewed, and, in the case of field bugs, deployed. Thus,\nthis experiment under-approximates static type systems’ positive impact on\nsoftware quality, especially when one considers all their other potential\nbenefits on documentation, program performance, code completion, and code\nnavigation.”</p>\n<h2>Definition and methodology</h2>\n<p>The team defined a bug as <code class=\"language-text\">ts-detectable</code><sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup> when using type annotations would\ncause the program containing the bug to error on a line changed by\na bug fix, and when the new annotations are consistent with the fixed program.</p>\n<p>At the time of analysis (08/19/2015), there were 3,910,969 closed bug reports\non open-source JavaScript projects on GitHub. The authors wanted a 95% confidence\nlevel, and so selected 400 bugs at random for the experiment.</p>\n<p>For each bug, the researchers checked in both TypeScript and Flow whether it\nwas <code class=\"language-text\">ts-detectable</code>. To do so, they did a first-pass filter to see if the report\nis absolutely not type-related (for example, the bug was due to a misunderstanding\nof the specification), and if so was labeled undetectable. Next, the researchers\nlooked at the intended behavior of the bug fix and attempted to add annotations\nto cause the type system to error at the area of code patched by the bug fix.\nIf so, the sample was deemed <code class=\"language-text\">ts-detectable</code>, otherwise it was not.\nThe researchers also set a time-bound for each bug to 10 minutes, a number based\non preliminary sampling of bugs, after which the sample was deemed unknown.</p>\n<h2>Results</h2>\n<p>\n  <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/b9d2543172f4e4a8451901a241a9228f/68866/histo_tc_detectable.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n  \n  <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 590px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 47.63888888888889%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAABiklEQVQoz42Syy/EUBTG5z+1mSDBH2DFBksLsSSMIPFYkLARIiHEMxKhHSbz6PSpipnWPLS9n3NPa0wmk9DkpF/vPfd3v9NzMnEc4+eJol8t14UQpAS/hYg7mvco4p6Qexl5+E7z8ex8MqjoNnBbqfPhkC6oN0OSAq2vCPNHOp7sJC9KAb3BwMmdIhZPDE5cv7Awvl1gnbcCjK7m0WyHFBGySwouix+8Jy+L+7hk4Mx+GSvnFiduXTuY3C2yVgiYXVbQJHftMMbYWh435frfDqf3SsidmZy4eeVgYicFmgGGcioa5E6WPEJur8u1vx1OdQE3eoCDOYWA4S+w9A/gzF7/klUqeXhF5f8ngUnJ3cCfrouO7tMUu9OUB8PHwMIDlyz/IzcldZiMWzpCXSOVkWKNIAePb5x4rHpYOk3g1bcWZg807vJXJDB3qEM1fd67NwIU0lHTKE+OnmSxw5cXB7WPZByCwCf9ziUYhgHLNOC6LodtmfA8D45jo1SpQjdtvNJ6RdPpW6d1B98ZyupZWoWDSAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n    >\n      <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\"\n        alt=\"histo tc detectable\"\n        title=\"\"\n        src=\"/static/b9d2543172f4e4a8451901a241a9228f/6255c/histo_tc_detectable.png\"\n        srcset=\"/static/b9d2543172f4e4a8451901a241a9228f/375dc/histo_tc_detectable.png 148w,\n/static/b9d2543172f4e4a8451901a241a9228f/6b157/histo_tc_detectable.png 295w,\n/static/b9d2543172f4e4a8451901a241a9228f/6255c/histo_tc_detectable.png 590w,\n/static/b9d2543172f4e4a8451901a241a9228f/68866/histo_tc_detectable.png 720w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>The team was able to label all 400 bug samples: Each of Flow and TypeScript\ndetected 60 of the bugs. This means at the confidence level of 95%, the\npercentage of detectable bugs for both fall into [11.5%, 18.5%] with mean 15%.</p>\n<p>Note that note of the bugs were easy to determine: only 18 of the 400 hit the\ntime-box period of 10 minutes, mostly due to external modules and interfaces\nmaking it harder to isolate the area of interest. The team spent more time on\nthese bugs, utilizing the DefinitelyTyped published type definitions and documentation\nwhen necessary, and were able to classify them all.</p>\n<h3>Caveats</h3>\n<p>The authors think this greatly understates the impact of static typing, because:</p>\n<ul>\n<li>They only surveyed publicly visible bugs, which means any bug caught during\ndevelopment was not included. They also think public bugs are more often cause\nby misunderstanding of the specification, which type systems cannot detect.</li>\n<li>These results do not include any other strengths of static type systems, like\ndeveloper efficiency or app performance.</li>\n<li>This experiment uses relatively weak type systems of TypeScript and Flow.</li>\n<li>The authors have limited expertise in Flow and TypeScript, which means they\ncould have incorrectly deemed bug as undetectable.</li>\n</ul>\n<h3>What about the undetectable bugs?</h3>\n<p>\n  <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/3779949d69c3eaadc128e1e353d1b495/68866/histo_undetectability.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n  \n  <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 590px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 45.27777777777778%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAABMklEQVQoz6WS3VLDIBCF8/5vYa98Emf0AdSO1mQ6NoGENISfACHlCERre+OF3ZmdsyzwsSwUZVnCuBmtcAinE043elHu3kD5hM1Dg0jEstwI3L48gwwad2fg8m/PwH1VZuDmAui/F3i/xkmXC/0T2Hf0F4iQk0kRome71hDWudTvEK6vm+aK5vCJQy9x/0RRdRMedxwf7YTXWqJiExpusCUaXDu8tzo+oIeyPvc6VZ8gP7BcobUG2jgcjhqDcqij0lgxkw77TuIYcyUVkMZnnSKw7hXs7CEnBz/PGWStzdcuErlpGgg+RK2hpEBL13HPWoiRY+gZKCFQgoOQJufSnpFz1HUNztdxssIYA6UUxnGElDJuIJjjqUKI9QvFA6VUYIzltqb1KdZao+sYnHPn6pJ9AVyLuQAs5Ua5AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n    >\n      <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\"\n        alt=\"histo undetectability\"\n        title=\"\"\n        src=\"/static/3779949d69c3eaadc128e1e353d1b495/6255c/histo_undetectability.png\"\n        srcset=\"/static/3779949d69c3eaadc128e1e353d1b495/375dc/histo_undetectability.png 148w,\n/static/3779949d69c3eaadc128e1e353d1b495/6b157/histo_undetectability.png 295w,\n/static/3779949d69c3eaadc128e1e353d1b495/6255c/histo_undetectability.png 590w,\n/static/3779949d69c3eaadc128e1e353d1b495/68866/histo_undetectability.png 720w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>The vast majority of bugs that were undetectable were due to “specification errors”,\nwhich constituted 78% of total bugs. This is covered by <code class=\"language-text\">BranchError</code>, <code class=\"language-text\">PredError</code>,\n<code class=\"language-text\">UIError</code>, and the catch-all <code class=\"language-text\">SpecError</code> in the above histogram. This demonstrates\nthe importance of careful specification before development begins.</p>\n<p>The second most common error type was <code class=\"language-text\">StringError</code>, often due to a wrong URL.</p>\n<h3>Comparing TypeScript and Flow</h3>\n<p>While TypeScript and Flow had the same number of <code class=\"language-text\">ts-detectable</code> bugs, they\ndidn’t have complete overlap. There were 3 bugs that were only detectable\non Flow, and 3 only on TypeScript.</p>\n<p>In all of the three detectable in Flow but not TypeScript, the bug was a result of concatening\na possible undefined or null value with another string. For example:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> x <span class=\"token operator\">=</span> <span class=\"token string\">\" \"</span> <span class=\"token operator\">+</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">+</span> <span class=\"token string\">\" \"</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>This highlights a TypeScript weakness, at least as of version 2.0.</p>\n<p>Two of the three detectable in TypeScript but not Flow were due to Flow’s incomplete\nsupport for using string literals as an index.</p>\n<p>Also of note: of the 60 ts-detectable bugs, 22 of them needed null checks.\nThis is a feature added in TypeScript 2.0, and needs <code class=\"language-text\">--strictNullChecks</code> enabled.</p>\n<h2>Approximating the cost of using static typings</h2>\n<p>While it’s incredibly difficult to directly measure the effort for programmers\nto use a static type system, the authors tried to approximate this.</p>\n<p>They defined:</p>\n<ul>\n<li>A <code class=\"language-text\">token tax</code>, which was the number of tokens in an annotation needed\nto trigger a type error for the bug in question. The goal for this was to proxy the number of decisions\na programmer would take when adding type annotations.</li>\n<li>A <code class=\"language-text\">time tax</code>, which was the time spent adding annotations.</li>\n</ul>\n<p>Note that these measures are an underestimate of the real-world cost, because they\nare calculated for a single bug where the authors only intend to localize\ntheir annotation to target the bug in question.\nHowever, under the assumption that a project has embraced using a\nstatic type checker, the codebase would already have annotations prior\nto the bug being written. In other words, the cost to the developer\nwould only be the time and tokens needed at the time of the bug-introducing\nchange. Thus, these metrics are intended to track the incremental cost.</p>\n<p>Using these measures, the authors find that the mean annotation tax for each\nbug is: 1.7 tokens and 231 seconds for Flow, and 2.4 tokens and 306 seconds for TypeScript.</p>\n<p>The authors note this discrepency is largely due to Flow’s paradigm of strong type inference,\nand a more compact syntax for nullable types. In other words, Flow could frequently\ninfer types to a sufficient amount for the authors to not even need to read the\nbug report: they could just add a consistent type annotation from the code.</p>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\">\n<blockquote>\n<p>Definition for <code class=\"language-text\">ts-detectable</code>: Given a static type system <code class=\"language-text\">ts</code>, a bug <code class=\"language-text\">b</code> is\n<code class=\"language-text\">ts-detectable</code> when adding or changing type annotations causes the program <code class=\"language-text\">p</code>\ncontaining <code class=\"language-text\">b</code> to error on a line changed by a fix and the new annotations are\nconsistent with <code class=\"language-text\">f</code>, a fixed version of <code class=\"language-text\">p</code>.</p>\n</blockquote>\n<a href=\"#fnref-1\" class=\"footnote-backref\">↩</a>\n</li>\n</ol>\n</div>","frontmatter":{"title":"Quantifying Detectable Bugs in JavaScript","date":"March 24, 2019","description":"xcxc"},"fields":{"readingTime":{"text":"6 min read"}}}},"pageContext":{"slug":"/summary-quantifying-detectable-bugs-js/","previous":{"fields":{"slug":"/how-best-product-engineering-teams-max-value/"},"frontmatter":{"title":"How the best product engineering teams maximize value"}},"next":null}}