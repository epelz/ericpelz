{"data":{"site":{"siteMetadata":{"title":"Eric Pelz","author":"Eric Pelz"}},"markdownRemark":{"id":"8f315846-07a3-5c11-a85f-66026e0b21a2","excerpt":"“JavaScript is growing explosively and is now used in large mature projects even\noutside the web domain. JavaScript is also a dynamically typed language for…","html":"<p>“JavaScript is growing explosively and is now used in large mature projects even\noutside the web domain. JavaScript is also a dynamically typed language for\nwhich static type systems, notably Facebook’s Flow and Microsoft’s TypeScript,\nhave been written. What benefits do these static type systems provide?” “In this\nstudy, we empirically quantify how much static type systems improve software\nquality. This is measured against bugs that are public, actually checked in and\nvisible to other developers, potentially impacting them; public bugs notably\ninclude field bugs, which impact users. We consider public bugs because they are\nobservable in software repository histories. Public bugs are more likely to be\nerrors understanding the specification because they are usually tested and\nreviewed, and, in the case of field bugs, deployed. Thus, this experiment\nunder-approximates static type systems’ positive impact on software quality,\nespecially when one considers all their other potential benefits on\ndocumentation, program performance, code completion, and code navigation.” ”\nDefinition 2.1 (ts-detectable): Given a static type system ts, a bug b is\nts-detectable when adding or changing type annotations causes the program p\ncontaining b to error on a line changed by a fix and the new annotations are\nconsistent with f , a fixed version of p.” The authors randomly selected 400 of\nthe ~4 million closed issues of JavaScript projects on Github (sufficient to\nachieve 95% confidence level) They time-boxed annotating types for each bug to\n10 minutes. This 10 minute number was determined from a preliminary study on 78\nbugs sampled (where they found that 86.67% of bugs could be annotated or deemed\nnot ts-detectable within 10 minutes) Results: They were able to label all 400\nbugs as either detectable or undetected under Flow and TypeScript. Flow detected\n60, and TypeScript detected 60. At the confidence level of 95%, this means the\npercentage of detectable bugs for both Flow and TypeScript fall into [11.5%,\n18.5%] with mean 15%. Most of the bugs were easy to determine. Time-boxing to\nonly 10 minutes per bug, they were able to determine all ut 18 of the 400 bugs.\nThese remaining bugs took between 8 minutes to over a an hour of dedicated time\n(authors noted that some were quicker than the first iteration, due to\nincreasing expertise). Authors think this is a greatly understated impact of\nstatic typing, because: They only surveyed publicly visible bugs, which means\nany bug caught during development were not included. They also think public bugs\nare more often due to misunderstanding of the specification, which type systems\ncannot detect. This doesn’t include any other strengths of static type systems,\nlike developer efficiency or app performance. This experiment uses relatively\nweak type systems of TypeScript and Flow. The authors have limited expertise in\nFlow and TypeScript, which means they could have incorrectly deemed bug as\nundetectable. Classifying ts-undetectable bugs Most errors were “specification\nerrors” - 186/400 (55%). Errors implementing specification overwhelmingly\nconstitute 78%. This demonstrates the importance of careful specification before\ndevelopment. StringError was the second most common error type - errors caused\nby incorrect content of a string (e.g. wrong URL). Authors theorize this is due\nto: (1) lots of URLs and other strings in JavaScript, (2) the string type being\nvery opaque in most type systems. TypeScript 2.0 added null handling. 22 of the\n60 ts-detectable bugs needed null checks (i.e. they needed —strictNullChecks\nand TS 2.0, rather than TS 1.8). TypeScript and Flow’s coverage were largely\noverlapping, with 6 exceptions: 3 were only Flow-detectable and 3 were only\nTypeScript detectable. All three Flow-detectable-only bugs were due to\nconcatenating a possible undefined/null value with another string. For example,\nvar x = ” ” + null + ” ”; This highlighted a TypeScript weakness (at least as of\nversion 2.0). Two of the three TypeScript-detectable-only bugs were due to\nFlow’s incomplete support for using string literals as an index. Cost to\nannotate with types Directly measuring the effort programmers must spend to\nannotate programs with a static type system would be very hard. The authors\ninstead approximate: token tax, “the number of tokens in the added type\nannotations”, and time tax, “the time spent adding annotations.” Token tax aims\nto proxy the number of decisions a programmer must make when adding type\nannotations. That is, for a ts-detectable bugs, the number of tokens in the\nannotation needed to trigger a type error. These measures are a huge\nunderestimate, because they only measure the “annotation tax” in a per-bug\nmanner, where the authors have a very localized annotation effort determined\nonly to target the bug in question (not the entire file). They lie under the\nassumption that the project has fully embraced using a static type checker, so\nthe codebase would already be annotated prior to the bug being introduced. Thus,\ntheir metric measures just the time and tokens required for the <em>additional\nannotations</em> at the time of the bug-introducing change. In other words, it\nmeasures incrementally adding/annotating patches on an already annotated code\nbase. Using this measure, they find the mean per-bug annotation tax: For Flow\nthere are 1.7 tokens and 231 seconds required to detect a bug, and 2.4 tokens\nand 306 seconds for TypeScript. Why discrepancy? Flow implements stronger type\ninference, and has a more compact syntax for nullable types. This was most\ndramatic in the time saved — Flow frequently could infer types and thus the\nauthors did not even need to read the bug report and fix to add a consistent\ntype annotation.</p>\n<p>“Leveraging JavaScript project histories, we select a fixed bug and check out\nthe code just prior to the fix. We manually add type annotations to the buggy\ncode and test whether Flow and TypeScript report an error on the buggy code,\nthereby possibly prompting a developer to fix the bug before its public release.\nWe then report the proportion of bugs on which these type systems reported an\nerror. Evaluating static type systems against public bugs, which have survived\ntesting and review, is conservative: it understates their effectiveness at\ndetecting bugs during private development, not to mention their other benefits\nsuch as facilitating code search/completion and serving as documentation.\nDespite this uneven playing field, our central finding is that both static type\nsystems find an important percentage of public bugs: both Flow 0.30 and\nTypeScript 2.0 successfully detect 15%!.</p>","frontmatter":{"title":"Quantifying Detectable Bugs in JavaScript","date":"March 24, 2018","description":"xcxc"},"fields":{"readingTime":{"text":"6 min read"}}}},"pageContext":{"slug":"/summary-quantifying-detectable-bugs-js/","previous":{"fields":{"slug":"/designing-simpler-react-components/"},"frontmatter":{"title":"Designing Simpler React Components"}},"next":{"fields":{"slug":"/propel-new-engineers-code-review/"},"frontmatter":{"title":"How to propel new engineers with code review"}}}}