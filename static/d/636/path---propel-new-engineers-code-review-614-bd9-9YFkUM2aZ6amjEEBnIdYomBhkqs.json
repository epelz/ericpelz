{"data":{"site":{"siteMetadata":{"title":"Eric Pelz","author":"Eric Pelz"}},"markdownRemark":{"id":"b39c7930-7bc0-5d2b-8054-565214830ef2","excerpt":"Maximizing mentorship, improving code quality, and saving time Many think of code review as a tool to prevent bugs from hitting production, or\nto ensure that…","html":"<h2>Maximizing mentorship, improving code quality, and saving time</h2>\n<p>Many think of code review as a tool to prevent bugs from hitting production, or\nto ensure that code meets a certain quality bar. While it’s often those things,\nit’s also an incredible tool for mentorship. Since there’s already a second\nperson reading over the code, why not do it in a way that will teach and\ninspire?</p>\n<p>During my time at Asana, I’ve had the pleasure of being on a few different teams\nand onboarding a bunch of new engineers (some new graduates and some seasoned\nengineers), and have seen first hand the benefit of code review for mentorship.\nBut I’ve also seen code reviews gone wrong — for example, a diff that suffers\nfrom large issues, but the reviewer just responding with a simple “LGTM” or lots\nof surface-level nits. Though good code reviewing does take some time, I’ve\nfound some tips and tricks to best leverage that time, with the goals of\nmentoring new engineers, keeping team velocity high, and maintaining high\nquality code.</p>\n<h3>Code review is not the right tool for everything</h3>\n<p>While code review is awesome, it’s certainly not appropriate for all kinds of\nfeedback. By the time code reaches review, it’s already been written: an\nengineer has already thought through a design, implemented it, tested it, and\npolished everything up. Imagine going through these steps, and then hearing your\nreviewer say “this is a bad way to do this, you could’ve avoided X by doing Y.”\nThat’s extremely demotivating and necessitates large revisions and more\nfollow-up reviews. Instead, you should discuss changes before implementation —\neither through a design doc or even a simple conversation — to get buy-in for\nthe overall approach.</p>\n<p>For tasks that involve large design changes, write up a short outline of what\nyou plan to implement (which files, any changes to abstractions, how pieces will\nfit together) and share it with a teammate before you start coding. This will\nreveal so many great nuggets of learning: ways to structure your thinking and\nengineering design, implementation risks and alternative approaches, and ways to\nsplit up your changes into smaller chunks. I’ve found this leads to a noticeable\nimprovement in code quality, and the net time saving is incredible.</p>\n<h3>Tips when writing code</h3>\n<p>When you commit code, think about the code you’re about to commit from the\ncontext of a code reviewer. All of us <em>should</em> want the reviewer to have an easy\ntime — not only will it save them time, but will also improve the quality of\nfeedback you receive. Consider the following tips:</p>\n<h4>Give a detailed description and test plan in the commit message</h4>\n<p>It sounds silly, but the commit message is there for a reason! For UI changes,\nit’s extremely helpful to include a screenshot or animated GIF to show the\ninteractions. This will put your reviewer in the correct mindset to read your\nchanges, which will save them time in context switching and help them focus.</p>\n<h4>Point out any problems you’re aware of</h4>\n<p>One of my favorite things to do when sending out a code review is to mention\nproblems I can anticipate, quirks in my changes, or reasons for certain\ndecisions that I made. This is really helpful, for a few reasons:</p>\n<ul>\n<li>Highlights these areas for your reviewer so they can give input on whether\nthey agree, or give tips to alleviate risk</li>\n<li>Saves your reviewer time for code with complexity, as they can understand\n<em>why</em> the complexity is there</li>\n<li>A future engineer who looks at the code can find the review task, and can gain\ninsight into your thought process and decision</li>\n</ul>\n<h4>Split your commit into digestible chunks</h4>\n<p>This is a huge time-saver, and I believe also leads to better code. Splitting\ncommits into small chunks helps you be cognizant of bad test coverage, bad\ndocumentation, or other common issues. Additionally, it helps your reviewer by\nreducing the surface area of each commit, thus saving them time to understand\nthe context of the change and leads to better feedback.</p>\n<p>Note: Git provides some tools to help you do this, like\n<a href=\"https://git-scm.com/book/en/v2/Git-Tools-Interactive-Staging\">git add -i</a>.</p>\n<h4>Find you’re receiving similar feedback over and over?</h4>\n<p>Often when you’re new to an organization or codebase, it’s inevitable that\nyou’re going to hit a lot of small issues while you’re still getting used to the\nenvironment. For new engineers on my team, I’ve found it helpful to create a\ntask in our <a href=\"https://wavelength.asana.com/workstyle-what-is-a-1-1/\">1:1 project</a>\ncalled “Common Code Review Feedback”. Whenever one of us noticed a new common\ntheme in code review, we add it to this task. This serves two purposes: to\nprovide an avenue to discuss these items (e.g. why does this matter? how can I\nidentify this before code review?), as well as track progress towards better\nquality code. I’ve seen this in action a few times, and it’s served as an\namazing motivator and positive reinforcement — both for the committer, and the\nreviewer to see their feedback being heard.</p>\n<h3>Tips when reviewing code</h3>\n<h4>Strategies for efficient reviewing</h4>\n<p>It’s sometimes difficult to strike a good balance between a quick “LGTM”, only\nfinding surface-level issues in code, and spending hours reviewing a change.\nIt’s not easy, especially when changes aren’t in an area of the code that you’re\nvery familiar with. In these cases, I try to break down the code review process\ninto a few parts:</p>\n<ol>\n<li><strong>Get a high-level sense of the changes</strong><br>First, read the commit message.\nIf this is a UI change, look at a screenshot or GIF of the change.</li>\n<li><strong>Get a sense of the surface area of the changes</strong><br>Read the list of files\nthat were changed. Have you seen these files recently? If not, skim them\nfirst (API and documentation) to get a sense of them. If there’s way too much\ncontext to gain, consider cc’ing someone else.<br>By gaining more context of\nthe changed files, you can limit the number of times you add comments and\nlater keep reading to find out they were all for moot.</li>\n<li><strong>Skim the changes to see if there were any API, abstraction, or structural\nchanges</strong><br>Don’t look at the actual implementation changes yet. One of the\nmost important things to see is how the change fits into the overall system.\nIs there a follow-up change (by someone else) coming which is incompatible\nwith these changes? Will the changes lead to an intractable or complex\npattern that others will want to follow?<br> You may decide that the entire\napproach should be rethought. In these cases, be tactful in how you explain\nyour thoughts (I often choose to ask leading questions or relate to other\nexamples). Additionally, consider that you may be missing context and could\nbe wrong — the engineer probably had good reason to do what they chose.</li>\n<li><strong>Finally, look at the actual implementation changes and tests</strong><br>Now, once\nyou’re happy with the high level changes, go through the code and look for\nsurface-level feedback. For example, are their methods simple and easy to\nunderstand? Do they follow best practices and style guidelines? Have they\ngiven adequate comments? Do their changes have ample test coverage, or have a\ngood reason to miss tests?</li>\n</ol>\n<h4>Keep giving the same feedback?</h4>\n<p>This can be frustrating, especially if it’s to multiple people. Consider writing\na canonical example or documentation of the best practices and link to it in\nfuture code reviews. Not only will this save you typing, but will also mean that\nothers can read this reference, expand upon it, or ask you questions about the\nunderlying motivations or philosophy.</p>\n<p>One of my favorite ways to do this is as part of an “example component” and\n“example test”: actual code that lives and breathes like all other code, but\nwith the single purpose of educating on best practices and underlying\nmotivations.</p>\n<h4>Spending a lot of time on code review?</h4>\n<p>Is it with a specific person? Consider spending some time to reflect on the past\nfew code reviews. Do you notice any themes? There might be an underlying reason\nthey’re not improving, like a lack of clarity in the company’s engineering\nvalues, or a misalignment in some engineering philosophy. I’ve often found it\nhelpful to send articles or videos on certain areas in engineering, and to talk\nto the engineer in person.</p>\n<p>Do you frequently receive code that is hard to review? Tell the engineer! No one\nintentionally makes life difficult for their reviewer. Explain to them why the\ncode is difficult to review (e.g. the commits are too large, commit messages are\nconfusing, or the code is just too complex). It may also help to review the code\nwith them in person, which will help them see why it’s difficult to review.\nAdditionally, don’t be afraid to reject the change and ask them to address the\nissues with the commit structure or messages; the only way to improve this is to\nsurface the issue.</p>\n<h4>Giving way too many small nit comments?</h4>\n<p>Sometimes, especially for new engineers, there are many small but important\nthings to mention. It would be ideal for these to be handled by a compiler or\nlinter, but sometimes that isn’t possible. Be mindful of your feedback — it\nmight be best to only mention a subset at a time, or explain the high-level\nphilosophy of the style guidelines in person. Otherwise, you risk decision\nfatigue for yourself as the reviewer, and the engineer is likely to feel\noverwhelmed when seeing the never-ending stream of comments. You can always\ncontinue to teach the engineer, and they’ll absorb more information if you\nincrementally introduce them to new concepts and learnings.</p>\n<h4>Feeling overwhelmed by a review in your inbox?</h4>\n<p>Every so often, I’ll get a code review for something that I’m not super excited\nto look at. Whether it’s old code that I haven’t worked in months, or an area of\nthe codebase that’s notoriously complex. This is totally normal, but it’s not\ndoing anyone any good, so reflect on this and be real. It may be best to pass\nthe review to someone else who is a better person for the review, or, if it’s\nnot time sensitive, to snooze it for a few days.</p>\n<hr>\n<p><em>Thanks to Greg Slovacek for support and contributions, and to R.J. Aquino, Tim\nBavaro, Kevin Der, Bella Kazwell, Vincent Siao, and Isaac Wolkerstorfer for\nreviewing a draft.</em></p>","frontmatter":{"title":"How to propel new engineers with code review","date":"December 17, 2016","description":"Maximizing mentorship, improving code quality, and saving time"},"fields":{"readingTime":{"text":"9 min read"}}}},"pageContext":{"slug":"/propel-new-engineers-code-review/","previous":{"fields":{"slug":"/designing-simpler-react-components/"},"frontmatter":{"title":"Designing Simpler React Components"}},"next":{"fields":{"slug":"/circumventing-engineering-complexity/"},"frontmatter":{"title":"Circumventing engineering complexity"}}}}