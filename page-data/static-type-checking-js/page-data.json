{"componentChunkName":"component---src-templates-blog-post-js","path":"/static-type-checking-js/","result":{"data":{"site":{"siteMetadata":{"title":"Eric Pelz","author":"Eric Pelz"}},"markdownRemark":{"id":"69511d07-6ee8-5d44-a12f-ada16d41919d","excerpt":"It’s extremely common for engineering teams to debate the value of static versus\ndynamic typing systems. The last few years has seen a big rise in TypeScript…","html":"<p>It’s extremely common for engineering teams to debate the value of static versus\ndynamic typing systems. The last few years has seen a big rise in TypeScript and\nFlow usage, which add static type checking to JavaScript.</p>\n<p>Within an individual engineering team, it’s fairly difficult to determine the\nactual value that one attains from switching from a dynamic to static typing\nsystem.</p>\n<p>A group of researchers created a study to look into just this: do static type\nsystems improve software quality, and if so, by how much?</p>\n<p>This post summarizes the research published in\n<a href=\"http://ttendency.cs.ucl.ac.uk/projects/type_study/documents/type_study.pdf\">To Type or Not to Type: Quantifying Detectable Bugs in JavaScript</a>,\nby Gao et. al. IEEE 2017, with particular attention on aspects of the paper\napplicable to software engineering teams using JavaScript or its typed variants.</p>\n<p>Result: 15% of sampled JavaScript bugs were detectable by Flow 0.30 and\nTypeScript 2.0.</p>\n<h2>Definition and methodology</h2>\n<p>The research team classified a bug as <code class=\"language-text\">ts-detectable</code><sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup> if using type\nannotations would cause an error on a line changed by a bug fix, and when the\nnew type annotations are consistent with the fixed program.</p>\n<p>At the time of analysis (08/19/2015), there were 3,910,969 closed bug reports on\nopen-source JavaScript projects on GitHub. The authors wanted a 95% confidence\nlevel, and so sampled 400 bugs at random for the experiment.</p>\n<p>The researchers classified each bug as <code class=\"language-text\">ts-detectable</code> in each of TypeScript 2.0\nand Flow 0.30. First, they checked if the bug report was absolutely not\ntype-related (for example, if the bug was due to a misunderstanding of the\nproduct specification), and if so they labeled it as undetectable. Next, they\nlooked at the intended behavior of the bug fix and attempted to add type\nannotations to cause the type system to error at the area of code patched by the\nbug fix. If they could do this, the sample was deemed <code class=\"language-text\">ts-detectable</code>; otherwise\nit was not. The researchers also set a time-bound for each bug investigation to\n10 minutes, after which the bug was deemed unknown.</p>\n<h2>Results</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/b9d2543172f4e4a8451901a241a9228f/37523/histo_tc_detectable.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 47.972972972972975%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAABbElEQVQoz51STUvDQBDtH/UgqBdFRNT/4EUP9ihUwQ+0eK5U2pMXERXUtqbVQpuYNMkmrW1NW5vsc3eStEoJggOPebMfb96wm/L9AHGEnBMPggCch7XMsqY9zoknISUPKa1PggyjM8RDsyvuyYsc3sgPuUDmWsej2gubU0M+g5Tc3M03BRp0MPfEsHZaJTd6e4DVEwWsN6J6+UhB/pnRubHvJzkE0kWVIOOq5GAr+0r8vT3EfKYMuzuieuO8hmLF/dvhXkElyMiXGDaztUhwgMXDSiTIsX5WRaHsRA6DZIeJgu4ACwf/EJwdeepwaeLw98ixYPx4MSfBnR+Pcjl5FEATDuf2S7AihyvHCjWMv5Vcozz5XiQY4OLOIsi4qXeQpvE5WH+M7VwD7X7oMF3UcCv2ZSgtDy9Gn3jr4wv3jd7UIWMMrhuO4nme4KELwzBg6Dpsy4LjOFTLbNs26g0Nqm7CEXebmo43UZumiW/ip+q1fNX6+wAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"histo tc detectable\"\n        title=\"histo tc detectable\"\n        src=\"/static/b9d2543172f4e4a8451901a241a9228f/fcda8/histo_tc_detectable.png\"\n        srcset=\"/static/b9d2543172f4e4a8451901a241a9228f/12f09/histo_tc_detectable.png 148w,\n/static/b9d2543172f4e4a8451901a241a9228f/e4a3f/histo_tc_detectable.png 295w,\n/static/b9d2543172f4e4a8451901a241a9228f/fcda8/histo_tc_detectable.png 590w,\n/static/b9d2543172f4e4a8451901a241a9228f/37523/histo_tc_detectable.png 720w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>The team was able to label all 400 bug samples: Each of Flow and TypeScript\ndetected 60 of the bugs. This means at the confidence level of 95%, the\npercentage of detectable bugs for each falls into [11.5%, 18.5%] with mean 15%.</p>\n<p>Most of the bugs were easy to determine: only 18 of the 400 hit the time-box\nperiod of 10 minutes, mostly due to external modules and interfaces making it\nharder to isolate the source of the bug with type annotations. The team spent\nmore time on these bugs, utilizing published type definitions and documentation\nwhen necessary, and were able to classify them all.</p>\n<h3>Caveats</h3>\n<p>The authors think this greatly understates the impact of static typing, because:</p>\n<ul>\n<li>They only surveyed publicly visible bugs, which means any bug caught during\ndevelopment was not included. They also think public bugs are more often cause\nby misunderstanding of the specification, which type systems cannot detect.</li>\n<li>These results do not include any other strengths of static type systems, like\ndeveloper efficiency or app performance.</li>\n<li>This experiment uses the relatively weak type systems of TypeScript and Flow.</li>\n<li>The authors have limited expertise in Flow and TypeScript, which means they\ncould have incorrectly deemed bug as undetectable.</li>\n</ul>\n<h3>What about the undetectable bugs?</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/3779949d69c3eaadc128e1e353d1b495/37523/histo_undetectability.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 45.27027027027027%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAABMklEQVQoz6WS3VLDIBCF8/5vYa98Emf0AdSO1mQ6NoGENISfACHlCERre+OF3ZmdsyzwsSwUZVnCuBmtcAinE043elHu3kD5hM1Dg0jEstwI3L48gwwad2fg8m/PwH1VZuDmAui/F3i/xkmXC/0T2Hf0F4iQk0kRome71hDWudTvEK6vm+aK5vCJQy9x/0RRdRMedxwf7YTXWqJiExpusCUaXDu8tzo+oIeyPvc6VZ8gP7BcobUG2jgcjhqDcqij0lgxkw77TuIYcyUVkMZnnSKw7hXs7CEnBz/PGWStzdcuErlpGgg+RK2hpEBL13HPWoiRY+gZKCFQgoOQJufSnpFz1HUNztdxssIYA6UUxnGElDJuIJjjqUKI9QvFA6VUYIzltqb1KdZao+sYnHPn6pJ9AVyLuQAs5Ua5AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"histo undetectability\"\n        title=\"histo undetectability\"\n        src=\"/static/3779949d69c3eaadc128e1e353d1b495/fcda8/histo_undetectability.png\"\n        srcset=\"/static/3779949d69c3eaadc128e1e353d1b495/12f09/histo_undetectability.png 148w,\n/static/3779949d69c3eaadc128e1e353d1b495/e4a3f/histo_undetectability.png 295w,\n/static/3779949d69c3eaadc128e1e353d1b495/fcda8/histo_undetectability.png 590w,\n/static/3779949d69c3eaadc128e1e353d1b495/37523/histo_undetectability.png 720w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>The vast majority of bugs that were undetectable were due to “specification\nerrors”, which constituted 78% of total bugs. This is covered by <code class=\"language-text\">BranchError</code>,\n<code class=\"language-text\">PredError</code>, <code class=\"language-text\">UIError</code>, and the catch-all <code class=\"language-text\">SpecError</code> in the above histogram.\nThis demonstrates the importance of careful specification before development\nbegins.</p>\n<p>The second most common error type was <code class=\"language-text\">StringError</code>, often due to a wrong URL.</p>\n<h3>Comparing TypeScript and Flow</h3>\n<p>While TypeScript and Flow had the same number of <code class=\"language-text\">ts-detectable</code> bugs, they\ndon’t have complete overlap. There were 3 bugs that were only detectable on\nFlow, and 3 only on TypeScript.</p>\n<p>In all of the three bugs detectable in Flow but not TypeScript, the bug was a\nresult of concatening a possible undefined or null value with another string.\nFor example:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> x <span class=\"token operator\">=</span> <span class=\"token string\">\" \"</span> <span class=\"token operator\">+</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">+</span> <span class=\"token string\">\" \"</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>This highlights a TypeScript weakness, at least as of version 2.0, in its null\nhandling.</p>\n<p>Two of the three bugs detectable in TypeScript but not Flow were due to Flow’s\nincomplete support for using string literals as an index.</p>\n<p>Also of note: of the 60 ts-detectable bugs, 22 of them needed null checks. This\nis a feature added in TypeScript 2.0, and needs <code class=\"language-text\">--strictNullChecks</code> enabled.</p>\n<h2>Approximating the cost of using static typings</h2>\n<p>While it’s incredibly difficult to directly measure the effort for programmers\nto use a static type system, the authors tried to approximate this.</p>\n<p>They defined:</p>\n<ul>\n<li>A <code class=\"language-text\">token tax</code>, which was the number of tokens in an annotation needed to\ntrigger a type error for the bug in question. The goal for this was to proxy\nthe number of decisions a programmer would take when adding type annotations.</li>\n<li>A <code class=\"language-text\">time tax</code>, which was the time spent adding annotations.</li>\n</ul>\n<p>Note that these measures are an underestimate of the real-world cost, because\nthey are calculated for a single bug in which the authors only used type\nannotation to target the bug in question (and not the entire module).</p>\n<p>These metrics are only intended to track the incremental cost for each change a\ndeveloper makes. If we assume an entire project is already using a static type\nchecker, then the cost to a developer is only the time and tokens needed as part\nof their code change.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/c7a4a9afe910c9d017d2ae8a816ca0f5/442cb/annotation_tax.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 32.43243243243243%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsTAAALEwEAmpwYAAABKUlEQVQY0z1R7W6CQBDk/R+m2gdQCkIDP6qJJmKjqFAjCAiIBvzC6c2asMlkj9u92Z1Bu1wuyLIMx+OxQ57nksPwD2maIo5jHA6HrhZFkYB3rLEnSVJcr1dor9cLRNu2Asbz+UTT1DBNE47rYjyZwHEctKqPsVwuYRgmfhcLWJaN2WymSDOpaff7XT1uOkJOqU4nDAYDfBkGiqKAbdv46PVV/sZJ1XRdh6GGlWUpQ3v9T7iOi8fjAY3b1HWN6XSKIAhlCkmJ3W4HWnK73QRJkuB8PmOz2YhknklCYt/3weWEkBL04RCjkdWRMoIw7GxgFEUpeT6fK3hiDYO+ep73lswNJsojgo0/4zFyJZNTt9tAzpRZVZX8AN6v12usViuxg1vu93v17YuKf5YyvUd7bIosAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"annotation tax\"\n        title=\"annotation tax\"\n        src=\"/static/c7a4a9afe910c9d017d2ae8a816ca0f5/fcda8/annotation_tax.png\"\n        srcset=\"/static/c7a4a9afe910c9d017d2ae8a816ca0f5/12f09/annotation_tax.png 148w,\n/static/c7a4a9afe910c9d017d2ae8a816ca0f5/e4a3f/annotation_tax.png 295w,\n/static/c7a4a9afe910c9d017d2ae8a816ca0f5/fcda8/annotation_tax.png 590w,\n/static/c7a4a9afe910c9d017d2ae8a816ca0f5/442cb/annotation_tax.png 752w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>Using these measures, the authors find that the mean annotation tax for each bug\nis: 1.7 tokens and 231 seconds for Flow, and 2.4 tokens and 306 seconds for\nTypeScript.</p>\n<p>The authors note this discrepency is largely due to Flow’s paradigm of strong\ntype inference, and a more compact syntax for nullable types, which made it\nfaster for them to annotate.</p>\n<p>However, the authors also noted that the most time-consuming aspect of this\nproject was handling external modules and their typings. For many projects, Flow\ndidn’t have built-in support, and the team leaned on the TypeScript community’s\n<a href=\"https://github.com/DefinitelyTyped/DefinitelyTyped\">set of type definitions</a>.</p>\n<h2>Takeaways</h2>\n<p>The research is pretty clear that static typing <em>does</em> indeed help prevent a\nsignificant percentage of bugs, even for engineers not familiar with the\nlanguage or codebase.</p>\n<p>While it’s possible those bugs could have been caught through other means —\nsuch as testing or linting — there’s a huge benefit in preventing this class of\nissues as part of your development cycle (as opposed to your testing process).\nThere are also many other adjacent benefits of static typing that were not\nexplored in this research, such as improved code editor integration and faster\nnew engineer onboarding to a codebase.</p>\n<p>One takeaway from this research is that there is value in an incremental\nconversion of your codebase to static typing. The researchers did not convert\nentire projects and were still able to prevent bugs. Rather than hold off\nconversion until your team has bandwidth to fully migrate, start incrementally\nwith the most commonly edited files or those most susceptible to bugs.</p>\n<p>TypeScript and Flow performed similarly in the goal of preventing bugs, but may\nhave more significant differences in adoption in a company or toolkit. Use the\nsoftware that most fits your team’s needs and goals: the differences highlighted\nhere are negligable enough.</p>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\">\n<blockquote>\n<p>Definition for <code class=\"language-text\">ts-detectable</code>: Given a static type system <code class=\"language-text\">ts</code>, a bug <code class=\"language-text\">b</code>\nis <code class=\"language-text\">ts-detectable</code> when adding or changing type annotations causes the\nprogram <code class=\"language-text\">p</code> containing <code class=\"language-text\">b</code> to error on a line changed by a fix and the new\nannotations are consistent with <code class=\"language-text\">f</code>, a fixed version of <code class=\"language-text\">p</code>.</p>\n</blockquote>\n<a href=\"#fnref-1\" class=\"footnote-backref\">↩</a>\n</li>\n</ol>\n</div>","frontmatter":{"title":"Preventing JavaScript bugs with static type checking","date":"March 24, 2019","description":"Summarizing research on catching bugs with TypeScript and Flow"},"fields":{"readingTime":{"text":"7 min read"}}}},"pageContext":{"slug":"/static-type-checking-js/","previous":{"fields":{"slug":"/how-best-product-engineering-teams-max-value/"},"frontmatter":{"title":"How the best product engineering teams maximize value"}},"next":null}},"staticQueryHashes":["2098522439","63159454"]}